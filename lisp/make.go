package lisp

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/xoba/turd/cnfg"
	"github.com/xoba/turd/thash"
)

const (
	optimize = true
	pkg      = "lisp"
)

func CompileDefuns(cnfg.Config) error {
	if err := os.MkdirAll(pkg, os.ModePerm); err != nil {
		return err
	}
	const (
		filename = "gen.go"
		autogen  = "THIS FILE IS AUTOGENERATED, DO NOT EDIT!"
	)
	file := filepath.Join(pkg, filename)
	f, err := os.Create(file)
	if err != nil {
		return err
	}
	fmt.Fprintf(f, `// %[1]s

package %[2]s

import "fmt"

func init() {
return
fmt.Println("%[3]s: %[4]s");
}
`, autogen, path.Base(pkg), filename, autogen)
	fmt.Fprintln(f, `var( L = list
A = apply
)
`)
	fmt.Fprintf(f, `func parse_env(s string) Exp {
e,err:= Parse(s)
if err != nil {
panic(err)
}
return e
}

`)

	// definitions referenced by eval need
	// to be compiled, since eval is compiled
	type definition struct {
		file     string
		name     string
		expr     Exp
		compiled bool
	}

	var defs []*definition

	load := func(dir string, compiled bool) error {
		files, err := ioutil.ReadDir(dir)
		if err != nil {
			return err
		}
		for _, fi := range files {
			if name := fi.Name(); filepath.Ext(name) == ".lisp" {
				def := &definition{
					file:     filepath.Join(dir, name),
					compiled: compiled,
				}
				buf, err := ioutil.ReadFile(def.file)
				if err != nil {
					return err
				}
				e, err := Parse(string(buf))
				if err != nil {
					return err
				}
				def.name = String(cadr(e))
				def.expr = e
				defs = append(defs, def)
			}
		}
		return nil
	}

	load("defs/compiled", true)
	load("defs/interpreted", false)

	sort.Slice(defs, func(i, j int) bool {
		return defs[i].name < defs[j].name
	})

	c := context{
		cases: make(map[string]string),
		funcs: make(map[string]string),
	}
	for _, def := range defs {
		e := def.expr
		e = SanitizeGo(e)
		name := String(cadr(e))
		label, err := LabelExpr(e)
		if err != nil {
			return err
		}
		var msg string
		if def.compiled {
			msg = "compiled"
		} else {
			msg = "interpreted"
		}
		fmt.Fprintf(f, "\n\n//\n// %s (%s)\n//\n\n\n", def.name, msg)
		fmt.Fprintf(f, "var %[1]s_label = parse_env(%[2]q)\n", name, String(label))
		name, code, err := DefunCode(c, e)
		if err != nil {
			return err
		}
		if def.compiled {
			fmt.Fprint(f, string(code))
		}
		def.name = name
	}

	if true {
		fmt.Fprintln(f, c.emit())
	}

	fmt.Fprintf(f, "\n\nfunc init() { env = L(\n")
	for _, def := range defs {
		fmt.Fprintf(f, "L(%q,%s_label),\n", def.name, def.name)
	}
	fmt.Fprintf(f, ")}\n\n")

	if err := f.Close(); err != nil {
		return err
	}
	if err := Gofmt(file); err != nil {
		return err
	}
	return nil
}

func DefunCode(c context, defun Exp) (string, []byte, error) {
	if String(car(defun)) != "defun" {
		return "", nil, fmt.Errorf("not a defun")
	}
	name := String(cadr(defun))
	var args []Exp
	if x, ok := caddr(defun).([]Exp); ok {
		args = x
	} else {
		args = []Exp{caddr(defun)}
	}
	body := cadddr(defun)
	w := new(bytes.Buffer)

	fmt.Fprintf(w, "func %[1]s(args ... Exp) Exp {\n", name)
	var vars []string
	for i, a := range args {
		if !isString(a) {
			return name, nil, fmt.Errorf("not a string: %s", a)
		}
		v := String(a)
		fmt.Fprintf(w, "%s := args[%d];\n", v, i)
		vars = append(vars, v)
	}
	code, err := Compile(c, body, true, vars)
	if err != nil {
		return name, nil, err
	}
	fmt.Fprintf(w, "return %s\n}\n\n", string(code))
	return name, w.Bytes(), nil
}

func isString(e Exp) bool {
	switch e.(type) {
	case string:
		return true
	default:
		return false
	}
}

type context struct {
	cases map[string]string
	funcs map[string]string
}

func (c context) emit() string {
	w := new(bytes.Buffer)

	f := func(name string, m map[string]string) {
		var list []string
		for k := range m {
			list = append(list, k)
		}
		sort.Strings(list)
		fmt.Fprintf(w, "\n// %s:\n\n", name)
		for _, k := range list {
			fmt.Fprintf(w, ` 
%s
`, m[k])
		}
	}
	f("cases", c.cases)
	//f("funcs", c.funcs)

	return w.String()
}

// non-negligible chance of collision, but maybe worth it for brevity:
func smallHash(s string) string {
	return hex.EncodeToString(thash.Hash([]byte(s)))[:10]
}

func funcName(p, s string) string {
	clean := func(x string) string {
		w := new(bytes.Buffer)
		for _, r := range x {
			switch {
			case unicode.IsDigit(r), unicode.IsLetter(r):
				w.WriteRune(r)
			default:
				w.WriteRune('π')
			}
		}
		return w.String()
	}
	if p == "" {
		return fmt.Sprintf("F_%s", smallHash(s))
	}
	return fmt.Sprintf("F_%s_%s", clean(p), smallHash(s))
}

func CompileLazy(c context, e Exp, vars []string) ([]byte, error) {
	w := new(bytes.Buffer)
	list, ok := e.([]Exp)
	if !ok {
		return nil, fmt.Errorf("lazy not a list")
	}
	if len(list) != 2 {
		return nil, fmt.Errorf("malformed cond with %d parts: %s", len(list), e)
	}
	f := func(s string) string {
		name := funcName("", s)
		c.funcs[name] = fmt.Sprintf(`func %s(...Exp) Exp {
return %s
}
`, name, s)
		return fmt.Sprintf(`Func(func(...Exp) Exp {
return %s
})`, s)
	}
	fc := func(e Exp) (string, error) {
		switch t := e.(type) {
		case string:
			return t, nil
		case []Exp:
			switch {
			case len(t) == 0:
				return "Nil", nil
			case len(t) == 2 && String(t[0]) == "quote":
				return compileQuote(c, t[1], vars)
			}
		}
		pb, err := Compile(c, e, false, vars)
		if err != nil {
			return "", err
		}
		return f(string(pb)), nil
	}
	pf, err := fc(list[0])
	if err != nil {
		return nil, err
	}
	ef, err := fc(list[1])
	if err != nil {
		return nil, err
	}
	fmt.Fprintf(w, `L(
%s,
%s,
)`, pf, ef)
	return w.Bytes(), nil
}

func compileQuote(c context, x Exp, vars []string) (string, error) {
	switch t := x.(type) {
	case string:
		return fmt.Sprintf("%q", t), nil
	default:
		compiled, err := Compile(c, t, false, vars)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf(string(compiled)), nil
	}
}

func Compile(c context, e Exp, indent bool, vars []string) ([]byte, error) {
	w := new(bytes.Buffer)
	emit := func(list []string) {
		if indent {
			fmt.Fprintf(w, "A(\n%s,\n)", strings.Join(list, ",\n"))
		} else {
			fmt.Fprintf(w, "A(%s)", strings.Join(list, ","))
		}
	}
	lambda := func(e Exp, name string) error {
		var args []string
		for _, e := range cadar(e).([]Exp) {
			args = append(args, String(e))
		}
		var arglist []string
		for _, x := range cdr(e).([]Exp) {
			arg, err := Compile(c, x, false, vars)
			if err != nil {
				return err
			}
			arglist = append(arglist, string(arg))
		}
		fmt.Fprintf(w, `func() Exp {
var %[1]s func(... Exp) Exp
%[1]s = func(args ... Exp) Exp {
`,
			name,
		)
		for i, a := range args {
			fmt.Fprintf(w, "%s := args[%d]\n", a, i)
			vars = append(vars, a)
		}
		body, err := Compile(c, caddar(e), false, vars)
		if err != nil {
			return err
		}
		fmt.Fprintf(w, `return %[2]s
}
return %[1]s(%[3]s)
}()
`,
			name,
			string(body),
			strings.Join(arglist, ","),
		)
		return nil
	}

	switch e := e.(type) {
	case string:
		fmt.Fprint(w, e)
	case []Exp:
		n := len(e)
		switch {

		case n == 0:
			fmt.Fprintf(w, "Nil")

		case ExpToBool(eq(car(e), "quote")):
			q, err := compileQuote(c, e[1], vars)
			if err != nil {
				return nil, err
			}
			fmt.Fprint(w, q)

		case ExpToBool(eq(car(e), "cond")):

			if op, ok := isMaplikeCond(e); optimize && ok {

				var funcs, names []string

				for i, a := range e {
					if i == 0 {
						continue
					}
					if i == len(e)-1 {
						continue
					}
					eq := car(a)
					key := car(cdr(car(cdr(cdr(eq)))))
					sub, err := Compile(c, cadr(a), false, vars)
					if err != nil {
						return nil, err
					}
					name := funcName(String(key), string(sub))
					w := new(bytes.Buffer)
					fmt.Fprintf(w, `func %[1]s(%[2]s Exp) Exp {
return %[3]s
}`,
						name,
						strings.Join(vars, ","),
						string(sub),
					)
					f := w.String()
					names = append(names, String(key))
					funcs = append(funcs, name)
					c.cases[name] = f
				}

				fmt.Fprintf(w, "func() Exp {\n")
				kv := new(bytes.Buffer)
				for i, n := range names {
					fmt.Fprintf(kv, "%q: %s,\n", n, funcs[i])
				}
				mapname := fmt.Sprintf("map_%s", smallHash(kv.String()))
				{
					g := new(bytes.Buffer)
					// TODO: move map "m" to global and just reference it here, not re-create it
					fmt.Fprintf(g, "var %s =make( map[string]func(%s Exp) Exp)\n", mapname, strings.Join(vars, ","))
					fmt.Fprintf(g, "func init() {\n")
					fmt.Fprintf(g, " %s = map[string]func(%s Exp) Exp {\n", mapname, strings.Join(vars, ","))
					fmt.Fprint(g, kv)
					fmt.Fprintf(g, "}}\n")
					c.cases[mapname] = g.String()
				}
				t, err := Compile(c, cadr(e[len(e)-1]), false, vars)
				if err != nil {
					return nil, err
				}
				fmt.Fprintf(w, `if f,ok := %[4]s[String(%[1]s)]; ok {
return f(%[2]s)
}
return %[3]s
`,
					op,
					strings.Join(vars, ","),
					string(t),
					mapname,
				)
				fmt.Fprintf(w, "}()\n")
			} else {

				var list []string
				for i, a := range e {
					var f func(context, Exp, []string) ([]byte, error)
					if i == 0 {
						f = func(c context, e Exp, vars []string) ([]byte, error) {
							return Compile(c, e, true, vars)
						}
					} else {
						f = CompileLazy
					}
					sub, err := f(c, a, vars)
					if err != nil {
						return nil, err
					}
					list = append(list, string(sub))
				}
				emit(list)
			}

		case ExpToBool(eq(caar(e), "lambda")) || ExpToBool(eq(caar(e), "λ")):
			if err := lambda(e, "λ"); err != nil {
				return nil, err
			}

		case ExpToBool(eq(caar(e), "label")):
			expr := cons(car(cdr(cdr(car(e)))), cdr(e))
			if err := lambda(expr, String(cadar(e))); err != nil {
				return nil, err
			}

		default:
			var list []string
			for _, a := range e {
				sub, err := Compile(c, a, indent, vars)
				if err != nil {
					return nil, err
				}
				list = append(list, string(sub))
			}
			emit(list)
		}

	default:
		return nil, fmt.Errorf("can't compile %T", e)
	}
	return w.Bytes(), nil
}

func isMaplikeCond(e []Exp) (string, bool) {
	out := true
	if len(e) < 2 {
		out = false
	}
	ops := make(map[string]bool)
	for i, a := range e {
		if i == 0 {
			continue
		}
		test := car(a)
		if i == len(e)-1 {
			if String(test) != "'t" {
				out = false
			}
		} else {
			first := car(test)
			second := cadr(test)
			third := caddr(test)
			// need pattern (eq atom quote); i.e., atom==quote
			if String(first) != "eq" {
				out = false
			}
			op, ok := second.(string)
			if !ok {
				out = false
			}
			ops[op] = true
			if String(car(third)) != "quote" {
				out = false
			}
		}
	}
	if len(ops) != 1 {
		out = false
	}
	var op string
	for k := range ops {
		op = k
	}
	return op, out
}

func LabelExpr(defun Exp) (Exp, error) {
	if String(car(defun)) != "defun" {
		return nil, fmt.Errorf("not a defun: %s", String(defun))
	}
	name := cadr(defun)
	args := caddr(defun)
	body := cadddr(defun)
	q := func(s string) Exp {
		return s
	}
	nl := func(args ...Exp) Exp {
		return args
	}
	e := nl(
		q("label"),
		name,
		nl(
			q("lambda"),
			args,
			body,
		),
	)
	return e, nil
}

func Gofmt(file string) error {
	w := new(bytes.Buffer)
	cmd := exec.Command("gofmt", "-w", file)
	cmd.Stdout = w
	cmd.Stderr = w
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("%w: %q", err, w)
	}
	return nil
}
