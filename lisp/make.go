package lisp

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/xoba/turd/cnfg"
)

const pkg = "lisp"

func CompileDefuns(cnfg.Config) error {
	if err := os.MkdirAll(pkg, os.ModePerm); err != nil {
		return err
	}
	file := filepath.Join(pkg, "gen.go")
	f, err := os.Create(file)
	if err != nil {
		return err
	}
	fmt.Fprintf(f, "// THIS FILE IS AUTOGENERATED, DO NOT EDIT!\n\n")
	fmt.Fprintf(f, "package %s\n", path.Base(pkg))
	fmt.Fprint(f, "\n\n\n")
	fmt.Fprintln(f, "var L = list\n\n\n")

	var defs []string
	{
		const dir = "defs"
		files, err := ioutil.ReadDir(dir)
		if err != nil {
			return err
		}
		for _, fi := range files {
			if name := fi.Name(); filepath.Ext(name) == ".lisp" {
				defs = append(defs, filepath.Join(dir, name))
			}
		}
	}
	var names []string
	for _, def := range defs {
		buf, err := ioutil.ReadFile(def)
		if err != nil {
			return err
		}
		e, err := Parse(string(buf))
		if err != nil {
			return err
		}
		e = SanitizeGo(e)
		{
			name, env, err := LabelCode(e)
			if err != nil {
				return err
			}
			fmt.Fprintf(f, "var %s_label = %s\n", name, string(env))
		}
		name, code, err := DefunCode(e)
		if err != nil {
			return err
		}
		fmt.Fprint(f, string(code))
		names = append(names, name)
	}

	fmt.Fprintf(f, "\n\nfunc init() { env = L(\n")
	for _, n := range names {
		fmt.Fprintf(f, "L(%q,%s_label),\n", n, n)
	}
	fmt.Fprintf(f, ")}\n\n")

	if err := f.Close(); err != nil {
		return err
	}
	if err := Gofmt(file); err != nil {
		return err
	}
	return nil
}

func DefunCode(defun Exp) (string, []byte, error) {
	if String(car(defun)) != "defun" {
		return "", nil, fmt.Errorf("not a defun")
	}
	name := String(cadr(defun))
	var args []Exp
	if x, ok := caddr(defun).([]Exp); ok {
		args = x
	} else {
		args = []Exp{caddr(defun)}
	}
	body := cadddr(defun)
	w := new(bytes.Buffer)

	fmt.Fprintf(w, "func %[1]s(args ... Exp) Exp {\n", name)
	//fmt.Fprintf(w, "debug(%q,args...)\n", name)
	fmt.Fprintf(w, `if err:= checklen(%d,args); err != nil {
return err
}
`, len(args))
	for i, a := range args {
		if !isString(a) {
			return name, nil, fmt.Errorf("not a string: %s", a)
		}
		fmt.Fprintf(w, "%s := args[%d];\n", String(a), i)
	}
	code, err := Compile(body, true)
	if err != nil {
		return name, nil, err
	}
	fmt.Fprintf(w, "return %s\n}\n\n", string(code))
	return name, w.Bytes(), nil
}

func isString(e Exp) bool {
	switch e.(type) {
	case string:
		return true
	default:
		return false
	}
}

func CompileLazy(e Exp) ([]byte, error) {
	w := new(bytes.Buffer)
	list, ok := e.([]Exp)
	if !ok {
		return nil, fmt.Errorf("lazy not a list")
	}
	if len(list) != 2 {
		return nil, fmt.Errorf("malformed cond with %d parts: %s", len(list), e)
	}
	f := func(s string) string {
		return fmt.Sprintf(`Func(func(...Exp) Exp {
return %s
})`, s)
	}
	fc := func(e Exp) (string, error) {
		switch t := e.(type) {
		case string:
			return t, nil
		case []Exp:
			switch {
			case len(t) == 0:
				return "Nil", nil
			case len(t) == 2 && String(t[0]) == "quote":
				return compileQuote(t[1])
			}
		}
		pb, err := Compile(e, false)
		if err != nil {
			return "", err
		}
		return f(string(pb)), nil
	}
	pf, err := fc(list[0])
	if err != nil {
		return nil, err
	}
	ef, err := fc(list[1])
	if err != nil {
		return nil, err
	}
	fmt.Fprintf(w, `[]Exp{
%s,
%s,
}`, pf, ef)
	return w.Bytes(), nil
}

func compileQuote(x Exp) (string, error) {
	switch t := x.(type) {
	case string:
		return fmt.Sprintf("%q", t), nil
	default:
		compiled, err := Compile(t, false)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf(string(compiled)), nil
	}
}

func Compile(e Exp, indent bool) ([]byte, error) {
	w := new(bytes.Buffer)
	emit := func(msg string, list []string) {
		if indent {
			fmt.Fprintf(w, "%s(\n%s,\n)", msg, strings.Join(list, ",\n"))
		} else {
			fmt.Fprintf(w, "%s(%s)", msg, strings.Join(list, ","))
		}
	}
	switch e := e.(type) {
	case string:
		fmt.Fprint(w, e)
	case []Exp:
		n := len(e)
		switch {
		case n == 0:
			fmt.Fprintf(w, "Nil")
		case n == 2 && String(e[0]) == "quote":
			q, err := compileQuote(e[1])
			if err != nil {
				return nil, err
			}
			fmt.Fprint(w, q)
		case n > 1 && String(e[0]) == "lambda":
			panic("compiling lambda")
		case n > 1 && String(e[0]) == "label":
			panic("compiling label")
		case n > 1 && String(e[0]) == "cond":
			var list []string
			for i, a := range e {
				var f func(Exp) ([]byte, error)
				if i == 0 {
					f = func(e Exp) ([]byte, error) {
						return Compile(e, true)
					}
				} else {
					f = CompileLazy
				}
				sub, err := f(a)
				if err != nil {
					return nil, err
				}
				list = append(list, string(sub))
			}
			emit("apply", list)
		default:
			var list []string
			for _, a := range e {
				sub, err := Compile(a, indent)
				if err != nil {
					return nil, err
				}
				list = append(list, string(sub))
			}
			emit("apply", list)
		}
	}
	return w.Bytes(), nil
}

func LabelCode(defun Exp) (string, []byte, error) {
	if String(car(defun)) != "defun" {
		return "", nil, fmt.Errorf("not a defun")
	}
	name := cadr(defun)
	args := caddr(defun)
	body := cadddr(defun)
	q := func(s string) Exp {
		return s
	}
	nl := func(args ...Exp) Exp {
		return args
	}
	e := nl(
		q("label"),
		name,
		nl(
			q("lambda"),
			args,
			body,
		),
	)
	exp, err := ExpressionCode(e)
	return String(name), exp, err
}

func ExpressionCode(e Exp) ([]byte, error) {
	w := new(bytes.Buffer)
	switch t := e.(type) {
	case string:
		fmt.Fprintf(w, "%q", t)
	case []Exp:
		list := t
		var parts []string
		for _, x := range list {
			buf, err := ExpressionCode(x)
			if err != nil {
				return nil, err
			}
			parts = append(parts, string(buf))
		}
		fmt.Fprintf(w, "L(%s)", strings.Join(parts, ","))
	default:
		return nil, fmt.Errorf("ToExpression switch fallthrough: %T", t)
	}
	return w.Bytes(), nil
}

func Gofmt(file string) error {
	w := new(bytes.Buffer)
	cmd := exec.Command("gofmt", "-w", file)
	cmd.Stdout = w
	cmd.Stderr = w
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("%w: %q", err, w)
	}
	return nil
}
