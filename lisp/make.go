package lisp

import (
	"bytes"
	"crypto/md5"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/xoba/turd/cnfg"
)

const pkg = "lisp"

func CompileDefuns(cnfg.Config) error {
	if err := os.MkdirAll(pkg, os.ModePerm); err != nil {
		return err
	}
	const (
		filename = "gen.go"
		autogen  = "THIS FILE IS AUTOGENERATED, DO NOT EDIT!"
	)
	file := filepath.Join(pkg, filename)
	f, err := os.Create(file)
	if err != nil {
		return err
	}
	auto := func() {
		fmt.Fprintf(f, "\n\n// %s\n\n", autogen)
	}
	fmt.Fprintf(f, `// %[1]s

package %[2]s

import "fmt"

func init() {
return
fmt.Println("%[3]s: %[4]s");
}
`, autogen, path.Base(pkg), filename, autogen)
	fmt.Fprintln(f, `var( L = list
A = apply
)
`)
	fmt.Fprintf(f, `func parse_env(s string) Exp {
e,err:= Parse(s)
if err != nil {
panic(err)
}
return e
}

`)

	// definitions referenced by eval need
	// to be compiled, since eval is compiled
	type definition struct {
		file     string
		name     string
		expr     Exp
		compiled bool
	}

	var defs []*definition

	load := func(dir string, compiled bool) error {
		files, err := ioutil.ReadDir(dir)
		if err != nil {
			return err
		}
		for _, fi := range files {
			if name := fi.Name(); filepath.Ext(name) == ".lisp" {
				def := &definition{
					file:     filepath.Join(dir, name),
					compiled: compiled,
				}
				buf, err := ioutil.ReadFile(def.file)
				if err != nil {
					return err
				}
				e, err := Parse(string(buf))
				if err != nil {
					return err
				}
				def.name = String(cadr(e))
				def.expr = e
				defs = append(defs, def)
			}
		}
		return nil
	}

	load("defs/compiled", true)
	load("defs/interpreted", false)

	sort.Slice(defs, func(i, j int) bool {
		return defs[i].name < defs[j].name
	})

	c := context{
		funcs: make(map[string]string),
	}
	for _, def := range defs {
		e := def.expr
		e = SanitizeGo(e)
		name := String(cadr(e))
		label, err := LabelExpr(e)
		if err != nil {
			return err
		}
		var msg string
		if def.compiled {
			msg = "compiled"
		} else {
			msg = "interpreted"
		}
		fmt.Fprintf(f, "\n\n//\n// %s (%s)\n//\n\n\n", def.name, msg)
		fmt.Fprintf(f, "var %[1]s_label = parse_env(%[2]q)\n", name, String(label))
		name, code, err := DefunCode(c, e)
		if err != nil {
			return err
		}
		if def.compiled {
			fmt.Fprint(f, string(code))
		}
		if false {
			auto()
		}
		def.name = name
	}

	if false {
		fmt.Printf("emitting %d funcs\n", len(c.funcs))
		for k, v := range c.funcs {
			fmt.Fprintf(f, `// %s
%s
`, k, v)
		}
	}

	fmt.Fprintf(f, "\n\nfunc init() { env = L(\n")
	for _, def := range defs {
		fmt.Fprintf(f, "L(%q,%s_label),\n", def.name, def.name)
	}
	fmt.Fprintf(f, ")}\n\n")

	if err := f.Close(); err != nil {
		return err
	}
	if err := Gofmt(file); err != nil {
		return err
	}
	return nil
}

func DefunCode(c context, defun Exp) (string, []byte, error) {
	if String(car(defun)) != "defun" {
		return "", nil, fmt.Errorf("not a defun")
	}
	name := String(cadr(defun))
	var args []Exp
	if x, ok := caddr(defun).([]Exp); ok {
		args = x
	} else {
		args = []Exp{caddr(defun)}
	}
	body := cadddr(defun)
	w := new(bytes.Buffer)

	fmt.Fprintf(w, "func %[1]s(args ... Exp) Exp {\n", name)
	if false {
		fmt.Fprintf(w, `if err:= checklen(%d,args); err != nil {
return err
}
`, len(args))
	}
	for i, a := range args {
		if !isString(a) {
			return name, nil, fmt.Errorf("not a string: %s", a)
		}
		fmt.Fprintf(w, "%s := args[%d];\n", String(a), i)
	}
	code, err := Compile(c, body, true)
	if err != nil {
		return name, nil, err
	}
	fmt.Fprintf(w, "return %s\n}\n\n", string(code))
	return name, w.Bytes(), nil
}

func isString(e Exp) bool {
	switch e.(type) {
	case string:
		return true
	default:
		return false
	}
}

type context struct {
	funcs map[string]string
}

func CompileLazy(c context, e Exp) ([]byte, error) {
	w := new(bytes.Buffer)
	list, ok := e.([]Exp)
	if !ok {
		return nil, fmt.Errorf("lazy not a list")
	}
	if len(list) != 2 {
		return nil, fmt.Errorf("malformed cond with %d parts: %s", len(list), e)
	}
	f := func(s string) string {
		h := md5.New()
		h.Write([]byte(s))
		name := fmt.Sprintf("F%x", h.Sum(nil))
		c.funcs[name] = fmt.Sprintf(`func %s(...Exp) Exp {
return %s
}
`, name, s)
		return fmt.Sprintf(`Func(func(...Exp) Exp {
return %s
})`, s)
	}
	fc := func(e Exp) (string, error) {
		switch t := e.(type) {
		case string:
			return t, nil
		case []Exp:
			switch {
			case len(t) == 0:
				return "Nil", nil
			case len(t) == 2 && String(t[0]) == "quote":
				return compileQuote(c, t[1])
			}
		}
		pb, err := Compile(c, e, false)
		if err != nil {
			return "", err
		}
		return f(string(pb)), nil
	}
	pf, err := fc(list[0])
	if err != nil {
		return nil, err
	}
	ef, err := fc(list[1])
	if err != nil {
		return nil, err
	}
	fmt.Fprintf(w, `L(
%s,
%s,
)`, pf, ef)
	return w.Bytes(), nil
}

func compileQuote(c context, x Exp) (string, error) {
	switch t := x.(type) {
	case string:
		return fmt.Sprintf("%q", t), nil
	default:
		compiled, err := Compile(c, t, false)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf(string(compiled)), nil
	}
}

func Compile(c context, e Exp, indent bool) ([]byte, error) {
	w := new(bytes.Buffer)
	emit := func(list []string) {
		if indent {
			fmt.Fprintf(w, "A(\n%s,\n)", strings.Join(list, ",\n"))
		} else {
			fmt.Fprintf(w, "A(%s)", strings.Join(list, ","))
		}
	}
	lambda := func(e Exp, name string) error {
		body, err := Compile(c, caddar(e), false)
		if err != nil {
			return err
		}
		var args []string
		for _, e := range cadar(e).([]Exp) {
			args = append(args, String(e))
		}
		var arglist []string
		for _, x := range cdr(e).([]Exp) {
			arg, err := Compile(c, x, false)
			if err != nil {
				return err
			}
			arglist = append(arglist, string(arg))
		}
		fmt.Fprintf(w, `func() Exp {
var %[1]s func(... Exp) Exp
%[1]s = func(args ... Exp) Exp {
`,
			name,
		)

		if false {
			fmt.Fprintf(w, `	if err := checklen(%d, args); err != nil {
		return err
	}
`, len(args))
		}
		for i, a := range args {
			fmt.Fprintf(w, "%s := args[%d]\n", a, i)
		}

		fmt.Fprintf(w, `return %[2]s
}
return %[1]s(%[3]s)
}()
`,
			name,
			string(body),
			strings.Join(arglist, ","),
		)
		return nil
	}

	switch e := e.(type) {
	case string:
		fmt.Fprint(w, e)
	case []Exp:
		n := len(e)
		switch {
		case n == 0:
			fmt.Fprintf(w, "Nil")
		case Bool(eq(car(e), "quote")):
			q, err := compileQuote(c, e[1])
			if err != nil {
				return nil, err
			}
			fmt.Fprint(w, q)

		case Bool(eq(caar(e), "lambda")):
			if err := lambda(e, "lambda"); err != nil {
				return nil, err
			}
		case Bool(eq(caar(e), "label")):
			expr := cons(car(cdr(cdr(car(e)))), cdr(e))
			if err := lambda(expr, String(cadar(e))); err != nil {
				return nil, err
			}
		case Bool(eq(car(e), "cond")):
			var list []string
			for i, a := range e {
				var f func(context, Exp) ([]byte, error)
				if i == 0 {
					f = func(c context, e Exp) ([]byte, error) {
						return Compile(c, e, true)
					}
				} else {
					f = CompileLazy
				}
				sub, err := f(c, a)
				if err != nil {
					return nil, err
				}
				list = append(list, string(sub))
			}
			emit(list)
		default:
			var list []string
			for _, a := range e {
				sub, err := Compile(c, a, indent)
				if err != nil {
					return nil, err
				}
				list = append(list, string(sub))
			}
			emit(list)
		}
	}
	return w.Bytes(), nil
}

func LabelExpr(defun Exp) (Exp, error) {
	if String(car(defun)) != "defun" {
		return nil, fmt.Errorf("not a defun: %s", String(defun))
	}
	name := cadr(defun)
	args := caddr(defun)
	body := cadddr(defun)
	q := func(s string) Exp {
		return s
	}
	nl := func(args ...Exp) Exp {
		return args
	}
	e := nl(
		q("label"),
		name,
		nl(
			q("lambda"),
			args,
			body,
		),
	)
	return e, nil
}

func Gofmt(file string) error {
	w := new(bytes.Buffer)
	cmd := exec.Command("gofmt", "-w", file)
	cmd.Stdout = w
	cmd.Stderr = w
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("%w: %q", err, w)
	}
	return nil
}
