;; THIS FILE IS AUTOGENERATED, DO NOT EDIT!
(defun teval (t e a)
  (cond
   ((atom e) (tassoc (next t) e a))
   ((atom (car e))
    ((λ (op first rest)
       ((λ (second third)
	  (cond ;; TODO: can we compile funcall instead?
	   ((eq op 'funcall) (teval (next t) (cons
				    (teval (next t) first a) ;; the function
				    rest)          ;; the args
				   a))
	   
	   ((eq op 'quote)   (cadr e))
	   ((eq op 'cond)    (tevcon (next t)   (cdr e) a))
	   ((eq op 'list)    (tevlis (next t)   (cdr e) a))
	   
	   
;; "add" with 2 args (manual)
((eq op 'add) (add (teval (next t) first a) (teval (next t) second a)))

;; "after" with 2 args (manual)
((eq op 'after) (after (teval (next t) first a) (teval (next t) second a)))

;; "and" with 2 args (loaded)
((eq op 'and) (and (teval (next t) first a) (teval (next t) second a)))

;; "append" with 2 args (loaded)
((eq op 'append) (append (teval (next t) first a) (teval (next t) second a)))

;; "assoc" with 2 args (loaded)
((eq op 'assoc) (assoc (teval (next t) first a) (teval (next t) second a)))

;; "atom" with 1 args (axiom)
((eq op 'atom) (atom (teval (next t) first a)))

;; "caadr" with 1 args (loaded)
((eq op 'caadr) (caadr (teval (next t) first a)))

;; "caar" with 1 args (loaded)
((eq op 'caar) (caar (teval (next t) first a)))

;; "cadar" with 1 args (loaded)
((eq op 'cadar) (cadar (teval (next t) first a)))

;; "caddar" with 1 args (loaded)
((eq op 'caddar) (caddar (teval (next t) first a)))

;; "cadddar" with 1 args (loaded)
((eq op 'cadddar) (cadddar (teval (next t) first a)))

;; "caddddar" with 1 args (loaded)
((eq op 'caddddar) (caddddar (teval (next t) first a)))

;; "caddddr" with 1 args (loaded)
((eq op 'caddddr) (caddddr (teval (next t) first a)))

;; "cadddr" with 1 args (loaded)
((eq op 'cadddr) (cadddr (teval (next t) first a)))

;; "caddr" with 1 args (loaded)
((eq op 'caddr) (caddr (teval (next t) first a)))

;; "cadr" with 1 args (loaded)
((eq op 'cadr) (cadr (teval (next t) first a)))

;; "car" with 1 args (axiom)
((eq op 'car) (car (teval (next t) first a)))

;; "cdar" with 1 args (loaded)
((eq op 'cdar) (cdar (teval (next t) first a)))

;; "cddar" with 1 args (loaded)
((eq op 'cddar) (cddar (teval (next t) first a)))

;; "cdddar" with 1 args (loaded)
((eq op 'cdddar) (cdddar (teval (next t) first a)))

;; "cddr" with 1 args (loaded)
((eq op 'cddr) (cddr (teval (next t) first a)))

;; "cdr" with 1 args (axiom)
((eq op 'cdr) (cdr (teval (next t) first a)))

;; "concat" with 2 args (manual)
((eq op 'concat) (concat (teval (next t) first a) (teval (next t) second a)))

;; "cons" with 2 args (axiom)
((eq op 'cons) (cons (teval (next t) first a) (teval (next t) second a)))

;; "display" with 1 args (manual)
((eq op 'display) (display (teval (next t) first a)))

;; "eq" with 2 args (axiom)
((eq op 'eq) (eq (teval (next t) first a) (teval (next t) second a)))

;; "err" with 1 args (manual)
((eq op 'err) (err (teval (next t) first a)))

;; "eval" with 2 args (loaded)
((eq op 'eval) (eval (teval (next t) first a) (teval (next t) second a)))

;; "evcon" with 2 args (loaded)
((eq op 'evcon) (evcon (teval (next t) first a) (teval (next t) second a)))

;; "evlis" with 2 args (loaded)
((eq op 'evlis) (evlis (teval (next t) first a) (teval (next t) second a)))

;; "exp" with 3 args (manual)
((eq op 'exp) (exp (teval (next t) first a) (teval (next t) second a) (teval (next t) third a)))

;; "hash" with 1 args (manual)
((eq op 'hash) (hash (teval (next t) first a)))

;; "hashed" with 1 args (manual)
((eq op 'hashed) (hashed (teval (next t) first a)))

;; "inc" with 1 args (loaded)
((eq op 'inc) (inc (teval (next t) first a)))

;; "length" with 1 args (loaded)
((eq op 'length) (length (teval (next t) first a)))

;; "mul" with 2 args (manual)
((eq op 'mul) (mul (teval (next t) first a) (teval (next t) second a)))

;; "newkey" with 0 args (manual)
((eq op 'newkey) (newkey))

;; "next" with 1 args (loaded)
((eq op 'next) (next (teval (next t) first a)))

;; "not" with 1 args (loaded)
((eq op 'not) (not (teval (next t) first a)))

;; "null" with 1 args (loaded)
((eq op 'null) (null (teval (next t) first a)))

;; "or" with 2 args (loaded)
((eq op 'or) (or (teval (next t) first a) (teval (next t) second a)))

;; "pair" with 2 args (loaded)
((eq op 'pair) (pair (teval (next t) first a) (teval (next t) second a)))

;; "pub" with 1 args (manual)
((eq op 'pub) (pub (teval (next t) first a)))

;; "runes" with 1 args (manual)
((eq op 'runes) (runes (teval (next t) first a)))

;; "sign" with 2 args (manual)
((eq op 'sign) (sign (teval (next t) first a) (teval (next t) second a)))

;; "sub" with 2 args (manual)
((eq op 'sub) (sub (teval (next t) first a) (teval (next t) second a)))

;; "tassoc" with 3 args (loaded)
((eq op 'tassoc) (tassoc (teval (next t) first a) (teval (next t) second a) (teval (next t) third a)))

;; "test1" with 1 args (loaded)
((eq op 'test1) (test1 (teval (next t) first a)))

;; "test2" with 1 args (loaded)
((eq op 'test2) (test2 (teval (next t) first a)))

;; "test3" with 1 args (loaded)
((eq op 'test3) (test3 (teval (next t) first a)))

;; "teval" with 3 args (loaded)
((eq op 'teval) (teval (teval (next t) first a) (teval (next t) second a) (teval (next t) third a)))

;; "tevcon" with 3 args (loaded)
((eq op 'tevcon) (tevcon (teval (next t) first a) (teval (next t) second a) (teval (next t) third a)))

;; "tevlis" with 3 args (loaded)
((eq op 'tevlis) (tevlis (teval (next t) first a) (teval (next t) second a) (teval (next t) third a)))

;; "verify" with 3 args (manual)
((eq op 'verify) (verify (teval (next t) first a) (teval (next t) second a) (teval (next t) third a)))


	   
	   ;; resolve an unknown op:
	   ('t (teval (next t) (cons (tassoc (next t) op a)
			   (cdr e))
		     a))))
	
	(car  rest)   ;; second
	(cadr rest))) ;; third
     (car e)    ;; op
     (cadr e)   ;; first
     (cddr e))) ;; rest
   
   ;; initial macro concept, note the two evals:
   ((eq (caar e) 'macro)
    (teval (next t) (teval (next t) (cadddar e) (pair (caddar e) (cdr e))) a))
   
   ((eq (caar e) 'label)
    (teval (next t) (cons (caddar e) (cdr e))
	  (cons (list (cadar e) (car e)) a)))
   
   ((or ;; two different notations for lambda
     (eq (caar e) 'lambda)
     (eq (caar e) 'λ))
    (cond ;; two different forms for lambda
     ((atom (cadar e)) ; lexpr form (lambda x ...)
      (teval (next t) (caddar e)
	    (cons (list (cadar e) (tevlis (next t) (cdr e) a))
		  a)))
     ('t ; traditional form (lambda (x...) ...)
      (teval (next t) (caddar e)
	    (append (pair (cadar e) (tevlis (next t) (cdr e) a))
		    a)))))))
