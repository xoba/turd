;; THIS FILE IS AUTOGENERATED, DO NOT EDIT!
(defun teval (e a)
  (cond
   ((atom e) (tassoc e a))
   ((atom (car e))
    ((λ (op first rest)
       ((λ (second third)
	  (cond ;; TODO: can we compile funcall instead?
	   ((eq op 'funcall) (teval (cons
				    (teval first a) ;; the function
				    rest)          ;; the args
				   a))
	   
	   ((eq op 'quote)   (cadr e))
	   ((eq op 'cond)    (tevcon   (cdr e) a))
	   ((eq op 'list)    (tevlis   (cdr e) a))
	   
	   ;; "add" with 2 args (manual)
((eq op 'add) (add (teval first a) (teval second a)))

;; "after" with 2 args (manual)
((eq op 'after) (after (teval first a) (teval second a)))

;; "and" with 2 args (loaded)
((eq op 'and) (and (teval first a) (teval second a)))

;; "append" with 2 args (loaded)
((eq op 'append) (append (teval first a) (teval second a)))

;; "assoc" with 2 args (loaded)
((eq op 'assoc) (assoc (teval first a) (teval second a)))

;; "atom" with 1 args (axiom)
((eq op 'atom) (atom (teval first a)))

;; "caadr" with 1 args (loaded)
((eq op 'caadr) (caadr (teval first a)))

;; "caar" with 1 args (loaded)
((eq op 'caar) (caar (teval first a)))

;; "cadar" with 1 args (loaded)
((eq op 'cadar) (cadar (teval first a)))

;; "caddar" with 1 args (loaded)
((eq op 'caddar) (caddar (teval first a)))

;; "cadddar" with 1 args (loaded)
((eq op 'cadddar) (cadddar (teval first a)))

;; "caddddar" with 1 args (loaded)
((eq op 'caddddar) (caddddar (teval first a)))

;; "caddddr" with 1 args (loaded)
((eq op 'caddddr) (caddddr (teval first a)))

;; "cadddr" with 1 args (loaded)
((eq op 'cadddr) (cadddr (teval first a)))

;; "caddr" with 1 args (loaded)
((eq op 'caddr) (caddr (teval first a)))

;; "cadr" with 1 args (loaded)
((eq op 'cadr) (cadr (teval first a)))

;; "car" with 1 args (axiom)
((eq op 'car) (car (teval first a)))

;; "cdar" with 1 args (loaded)
((eq op 'cdar) (cdar (teval first a)))

;; "cddar" with 1 args (loaded)
((eq op 'cddar) (cddar (teval first a)))

;; "cdddar" with 1 args (loaded)
((eq op 'cdddar) (cdddar (teval first a)))

;; "cddr" with 1 args (loaded)
((eq op 'cddr) (cddr (teval first a)))

;; "cdr" with 1 args (axiom)
((eq op 'cdr) (cdr (teval first a)))

;; "concat" with 2 args (manual)
((eq op 'concat) (concat (teval first a) (teval second a)))

;; "cons" with 2 args (axiom)
((eq op 'cons) (cons (teval first a) (teval second a)))

;; "display" with 1 args (manual)
((eq op 'display) (display (teval first a)))

;; "eq" with 2 args (axiom)
((eq op 'eq) (eq (teval first a) (teval second a)))

;; "err" with 1 args (manual)
((eq op 'err) (err (teval first a)))

;; "eval" with 2 args (loaded)
((eq op 'eval) (eval (teval first a) (teval second a)))

;; "evcon" with 2 args (loaded)
((eq op 'evcon) (evcon (teval first a) (teval second a)))

;; "evlis" with 2 args (loaded)
((eq op 'evlis) (evlis (teval first a) (teval second a)))

;; "exp" with 3 args (manual)
((eq op 'exp) (exp (teval first a) (teval second a) (teval third a)))

;; "hash" with 1 args (manual)
((eq op 'hash) (hash (teval first a)))

;; "hashed" with 1 args (manual)
((eq op 'hashed) (hashed (teval first a)))

;; "inc" with 1 args (loaded)
((eq op 'inc) (inc (teval first a)))

;; "length" with 1 args (loaded)
((eq op 'length) (length (teval first a)))

;; "mul" with 2 args (manual)
((eq op 'mul) (mul (teval first a) (teval second a)))

;; "newkey" with 0 args (manual)
((eq op 'newkey) (newkey))

;; "next" with 1 args (loaded)
((eq op 'next) (next (teval first a)))

;; "not" with 1 args (loaded)
((eq op 'not) (not (teval first a)))

;; "null" with 1 args (loaded)
((eq op 'null) (null (teval first a)))

;; "or" with 2 args (loaded)
((eq op 'or) (or (teval first a) (teval second a)))

;; "pair" with 2 args (loaded)
((eq op 'pair) (pair (teval first a) (teval second a)))

;; "pub" with 1 args (manual)
((eq op 'pub) (pub (teval first a)))

;; "runes" with 1 args (manual)
((eq op 'runes) (runes (teval first a)))

;; "sign" with 2 args (manual)
((eq op 'sign) (sign (teval first a) (teval second a)))

;; "sub" with 2 args (manual)
((eq op 'sub) (sub (teval first a) (teval second a)))

;; "tassoc" with 3 args (loaded)
((eq op 'tassoc) (tassoc (teval first a) (teval second a) (teval third a)))

;; "test1" with 1 args (loaded)
((eq op 'test1) (test1 (teval first a)))

;; "test2" with 1 args (loaded)
((eq op 'test2) (test2 (teval first a)))

;; "test3" with 1 args (loaded)
((eq op 'test3) (test3 (teval first a)))

;; "teval" with 2 args (loaded)
((eq op 'teval) (teval (teval first a) (teval second a)))

;; "tevcon" with 2 args (loaded)
((eq op 'tevcon) (tevcon (teval first a) (teval second a)))

;; "tevlis" with 2 args (loaded)
((eq op 'tevlis) (tevlis (teval first a) (teval second a)))

;; "verify" with 3 args (manual)
((eq op 'verify) (verify (teval first a) (teval second a) (teval third a)))


	   
	   ;; resolve an unknown op:
	   ('t (teval (cons (tassoc op a)
			   (cdr e))
		     a))))
	
	(car  rest)   ;; second
	(cadr rest))) ;; third
     (car e)    ;; op
     (cadr e)   ;; first
     (cddr e))) ;; rest
   
   ;; initial macro concept, note the two evals:
   ((eq (caar e) 'macro)
    (teval (teval (cadddar e) (pair (caddar e) (cdr e))) a))
   
   ((eq (caar e) 'label)
    (teval (cons (caddar e) (cdr e))
	  (cons (list (cadar e) (car e)) a)))
   
   ((or ;; two different notations for lambda
     (eq (caar e) 'lambda)
     (eq (caar e) 'λ))
    (cond ;; two different forms for lambda
     ((atom (cadar e)) ; lexpr form (lambda x ...)
      (teval (caddar e)
	    (cons (list (cadar e) (tevlis (cdr e) a))
		  a)))
     ('t ; traditional form (lambda (x...) ...)
      (teval (caddar e)
	    (append (pair (cadar e) (tevlis (cdr e) a))
		    a)))))))
