;; THIS FILE IS AUTOGENERATED, DO NOT EDIT!
(defun teval (t0 e a) ;; t0 is time spec
  ((lambda (t1) ;; t1 is the next time spec
      (cond
        ((atom e) (tassoc t1 e a))
        ((atom (car e))
          ((λ (op first rest)
              ((λ (second third)
                  (cond ;; TODO: can we compile funcall instead?
                    ((eq op 'funcall) (teval t1 (cons
                          (teval t1 first a) ;; the function
                          rest) ;; the args
                        a))
                    ((eq op 'quote) first)
                    ((eq op 'cond) (tevcon t1 (cdr e) a))
                    ((eq op 'list) (tevlis t1 (cdr e) a))
                    ;; "add" with 2 args (manual)
                    ((eq op 'add) (add (teval t1 first a) (teval t1 second a)))
                    ;; "after" with 2 args (manual)
                    ((eq op 'after) (after (teval t1 first a) (teval t1 second a)))
                    ;; "and" with 2 args (loaded)
                    ((eq op 'and) (and (teval t1 first a) (teval t1 second a)))
                    ;; "append" with 2 args (loaded)
                    ((eq op 'append) (append (teval t1 first a) (teval t1 second a)))
                    ;; "assoc" with 2 args (loaded)
                    ((eq op 'assoc) (assoc (teval t1 first a) (teval t1 second a)))
                    ;; "atom" with 1 args (axiom)
                    ((eq op 'atom) (atom (teval t1 first a)))
                    ;; "caadr" with 1 args (loaded)
                    ((eq op 'caadr) (caadr (teval t1 first a)))
                    ;; "caar" with 1 args (loaded)
                    ((eq op 'caar) (caar (teval t1 first a)))
                    ;; "cadar" with 1 args (loaded)
                    ((eq op 'cadar) (cadar (teval t1 first a)))
                    ;; "caddar" with 1 args (loaded)
                    ((eq op 'caddar) (caddar (teval t1 first a)))
                    ;; "cadddar" with 1 args (loaded)
                    ((eq op 'cadddar) (cadddar (teval t1 first a)))
                    ;; "caddddar" with 1 args (loaded)
                    ((eq op 'caddddar) (caddddar (teval t1 first a)))
                    ;; "caddddr" with 1 args (loaded)
                    ((eq op 'caddddr) (caddddr (teval t1 first a)))
                    ;; "cadddr" with 1 args (loaded)
                    ((eq op 'cadddr) (cadddr (teval t1 first a)))
                    ;; "caddr" with 1 args (loaded)
                    ((eq op 'caddr) (caddr (teval t1 first a)))
                    ;; "cadr" with 1 args (loaded)
                    ((eq op 'cadr) (cadr (teval t1 first a)))
                    ;; "car" with 1 args (axiom)
                    ((eq op 'car) (car (teval t1 first a)))
                    ;; "cdar" with 1 args (loaded)
                    ((eq op 'cdar) (cdar (teval t1 first a)))
                    ;; "cddar" with 1 args (loaded)
                    ((eq op 'cddar) (cddar (teval t1 first a)))
                    ;; "cdddar" with 1 args (loaded)
                    ((eq op 'cdddar) (cdddar (teval t1 first a)))
                    ;; "cddr" with 1 args (loaded)
                    ((eq op 'cddr) (cddr (teval t1 first a)))
                    ;; "cdr" with 1 args (axiom)
                    ((eq op 'cdr) (cdr (teval t1 first a)))
                    ;; "concat" with 2 args (manual)
                    ((eq op 'concat) (concat (teval t1 first a) (teval t1 second a)))
                    ;; "cons" with 2 args (axiom)
                    ((eq op 'cons) (cons (teval t1 first a) (teval t1 second a)))
                    ;; "display" with 1 args (manual)
                    ((eq op 'display) (display (teval t1 first a)))
                    ;; "eq" with 2 args (axiom)
                    ((eq op 'eq) (eq (teval t1 first a) (teval t1 second a)))
                    ;; "err" with 1 args (manual)
                    ((eq op 'err) (err (teval t1 first a)))
                    ;; "eval" with 2 args (loaded)
                    ((eq op 'eval) (eval (teval t1 first a) (teval t1 second a)))
                    ;; "evcon" with 2 args (loaded)
                    ((eq op 'evcon) (evcon (teval t1 first a) (teval t1 second a)))
                    ;; "evlis" with 2 args (loaded)
                    ((eq op 'evlis) (evlis (teval t1 first a) (teval t1 second a)))
                    ;; "exp" with 3 args (manual)
                    ((eq op 'exp) (exp (teval t1 first a) (teval t1 second a) (teval t1 third a)))
                    ;; "factorial" with 1 args (loaded)
                    ((eq op 'factorial) (factorial (teval t1 first a)))
                    ;; "hash" with 1 args (manual)
                    ((eq op 'hash) (hash (teval t1 first a)))
                    ;; "hashed" with 1 args (manual)
                    ((eq op 'hashed) (hashed (teval t1 first a)))
                    ;; "inc" with 1 args (loaded)
                    ((eq op 'inc) (inc (teval t1 first a)))
                    ;; "length" with 1 args (loaded)
                    ((eq op 'length) (length (teval t1 first a)))
                    ;; "mul" with 2 args (manual)
                    ((eq op 'mul) (mul (teval t1 first a) (teval t1 second a)))
                    ;; "newkey" with 0 args (manual)
                    ((eq op 'newkey) (newkey))
                    ;; "next" with 1 args (loaded)
                    ((eq op 'next) (next (teval t1 first a)))
                    ;; "not" with 1 args (loaded)
                    ((eq op 'not) (not (teval t1 first a)))
                    ;; "null" with 1 args (loaded)
                    ((eq op 'null) (null (teval t1 first a)))
                    ;; "or" with 2 args (loaded)
                    ((eq op 'or) (or (teval t1 first a) (teval t1 second a)))
                    ;; "pair" with 2 args (loaded)
                    ((eq op 'pair) (pair (teval t1 first a) (teval t1 second a)))
                    ;; "pub" with 1 args (manual)
                    ((eq op 'pub) (pub (teval t1 first a)))
                    ;; "runes" with 1 args (manual)
                    ((eq op 'runes) (runes (teval t1 first a)))
                    ;; "sign" with 2 args (manual)
                    ((eq op 'sign) (sign (teval t1 first a) (teval t1 second a)))
                    ;; "sub" with 2 args (manual)
                    ((eq op 'sub) (sub (teval t1 first a) (teval t1 second a)))
                    ;; "tassoc" with 3 args (loaded)
                    ((eq op 'tassoc) (tassoc (teval t1 first a) (teval t1 second a) (teval t1 third a)))
                    ;; "test1" with 1 args (loaded)
                    ((eq op 'test1) (test1 (teval t1 first a)))
                    ;; "test2" with 1 args (loaded)
                    ((eq op 'test2) (test2 (teval t1 first a)))
                    ;; "test3" with 1 args (loaded)
                    ((eq op 'test3) (test3 (teval t1 first a)))
                    ;; "teval" with 3 args (loaded)
                    ((eq op 'teval) (teval (teval t1 first a) (teval t1 second a) (teval t1 third a)))
                    ;; "tevcon" with 3 args (loaded)
                    ((eq op 'tevcon) (tevcon (teval t1 first a) (teval t1 second a) (teval t1 third a)))
                    ;; "tevlis" with 3 args (loaded)
                    ((eq op 'tevlis) (tevlis (teval t1 first a) (teval t1 second a) (teval t1 third a)))
                    ;; "verify" with 3 args (manual)
                    ((eq op 'verify) (verify (teval t1 first a) (teval t1 second a) (teval t1 third a)))
                    ;; resolve an unknown op:
                    ('t (teval t1 (cons (tassoc t1 op a)
                          (cdr e))
                        a))))
                (car rest) ;; second
                (cadr rest))) ;; third
            (car e) ;; op
            (cadr e) ;; first
            (cddr e))) ;; rest
        ;; initial macro concept, note the two evals:
        ((eq (caar e) 'macro)
          (teval t1 (teval t1 (cadddar e) (pair (caddar e) (cdr e))) a))
        ((eq (caar e) 'label)
          (teval t1 (cons (caddar e) (cdr e))
            (cons (list (cadar e) (car e)) a)))
        ((or ;; two different notations for lambda
            (eq (caar e) 'lambda)
            (eq (caar e) 'λ))
          (cond ;; two different forms for lambda
            ((atom (cadar e)) ; lexpr form (lambda x ...)
              (teval t1 (caddar e)
                (cons (list (cadar e) (tevlis t1 (cdr e) a))
                  a)))
            ('t ; traditional form (lambda (x...) ...)
              (teval t1 (caddar e)
                (append (pair (cadar e) (tevlis t1 (cdr e) a))
                  a))))))
      )
    (next t0)))
